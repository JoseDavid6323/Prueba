<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Guardianes — Juego</title>
<style>
  :root{
    --bg:#0b1020; --panel:#0f1724; --accent:#c8102e; --muted:#98a0b3; --green:#2ecc71;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial; background:linear-gradient(180deg,var(--bg),#07101a); color:#e6eef8}
  .wrap{max-width:1100px;margin:18px auto;padding:16px}
  header{display:flex;align-items:center;gap:12px}
  .logo{width:56px;height:56px;border-radius:8px;background:linear-gradient(135deg,var(--accent),#ff7a7a);display:flex;align-items:center;justify-content:center;font-weight:800}
  h1{font-size:20px;margin:0}
  .controls{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
  .panel{background:rgba(255,255,255,0.03);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 18px rgba(0,0,0,0.6)}
  #game-area{display:flex;gap:12px;margin-top:14px}
  canvas{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:8px;display:block}
  .sidebar{width:320px;display:flex;flex-direction:column;gap:12px}
  .info{padding:10px}
  .btn{background:var(--accent);border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .small{font-size:13px;color:var(--muted)}
  footer{margin-top:14px;font-size:13px;color:var(--muted);text-align:center}
  @media(max-width:900px){.wrap{padding:8px}.sidebar{width:100%} #game-area{flex-direction:column}}
  /* HUD overlays */
  .hud { position:absolute; left:18px; top:18px; background:rgba(0,0,0,0.25); padding:8px 12px; border-radius:8px; font-weight:600 }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="logo">G</div>
    <div>
      <h1>Guardianes</h1>
      <div class="small">Defiende la base. Mueve: WASD / Flechas. Dispara: Barra espaciadora.</div>
    </div>
  </header>

  <div class="controls" style="margin-top:10px">
    <button id="startBtn" class="btn">Comenzar Partida</button>
    <button id="pauseBtn" class="btn secondary">Pausar</button>
    <button id="resetBtn" class="btn secondary">Reiniciar</button>
    <div style="margin-left:auto" class="small panel info">
      <div>Mejoras: dispara ráfaga al recoger power-up verde.</div>
    </div>
  </div>

  <div id="game-area">
    <div style="position:relative; flex:1;" class="panel">
      <canvas id="gameCanvas" width="820" height="480"></canvas>
      <div id="hud" class="hud">Score: 0 &nbsp; Lives: 3</div>
    </div>

    <div class="sidebar">
      <div class="panel info">
        <h3 style="margin:0 0 8px 0">Información</h3>
        <div class="small">Enemigos: se acercan desde la derecha. Evítalos o destrúyelos. Entre oleadas, aparecerán power-ups.</div>
      </div>

      <div class="panel info">
        <h4 style="margin:0 0 6px 0">Controles</h4>
        <ul class="small" style="margin:0;padding-left:16px">
          <li>Mover: WASD o Flechas</li>
          <li>Disparar: Barra espaciadora</li>
          <li>Pausa: Botón Pausar</li>
        </ul>
      </div>

      <div class="panel info">
        <h4 style="margin:0 0 6px 0">Puntuaciones</h4>
        <div id="highscore" class="small">Mejor: 0</div>
      </div>
    </div>
  </div>

  <footer class="small">Hecho por José · Guarda este archivo como <code>index.html</code> y súbelo a GitHub Pages</footer>
</div>

<script>
/* Juego Guardianes - Un solo archivo
   - Controles: WASD / flechas; espacio para disparar
   - Objetos: jugador, balas, enemigos, power-ups
   - Guardado de highscore en localStorage
*/

/* === Configuración y estado === */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let GAME = {
  running: false,
  paused: false,
  score: 0,
  lives: 3,
  wave: 1,
  highscore: parseInt(localStorage.getItem('guardianes_high')) || 0
};

/* Tamaño y escalado */
const W = canvas.width, H = canvas.height;

/* Jugador */
const player = {
  x: 80, y: H/2, w: 36, h: 36,
  speed: 4,
  color: '#1bd6ff',
  cooldown: 0,
  fireRate: 14, // frames between shots
  burst: false, // mejora
  burstTime: 0
};

/* Arrays del juego */
let bullets = [];
let enemies = [];
let powerups = [];
let particles = [];

/* Input */
const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if ([' ','spacebar'].includes(e.key.toLowerCase())) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

/* UI */
const startBtn = document.getElementById('startBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const hud = document.getElementById('hud');
const highscoreEl = document.getElementById('highscore');

highscoreEl.innerText = 'Mejor: ' + GAME.highscore;

/* === Funciones de creación === */
function spawnEnemy() {
  // enemigos con vida y velocidad aleatoria
  const size = Math.random() < 0.2 ? 28 : (Math.random() < 0.5 ? 22 : 18);
  const y = 30 + Math.random() * (H - 60);
  const hp = size > 25 ? 3 : size > 20 ? 2 : 1;
  const speed = 1.0 + Math.random() * (0.6 + GAME.wave*0.12);
  enemies.push({ x: W + 40, y, w: size, h: size, hp, speed, color: '#ffb86b' });
}

function spawnPowerup() {
  const y = 40 + Math.random() * (H - 80);
  powerups.push({ x: W + 30, y, r: 12, kind: 'burst', speed: 1.2, color: '#7ee787' });
}

/* Partículas simples */
function addParticles(x,y,color,count=8) {
  for(let i=0;i<count;i++){
    particles.push({
      x, y,
      vx: (Math.random()-0.5)*3,
      vy: (Math.random()-0.5)*3,
      life: 30 + Math.random()*30,
      color
    });
  }
}

/* === Lógica === */
function resetGame(){
  GAME.running = false;
  GAME.paused = false;
  GAME.score = 0;
  GAME.lives = 3;
  GAME.wave = 1;
  bullets = []; enemies=[]; powerups=[]; particles=[];
  player.x = 80; player.y = H/2; player.cooldown = 0; player.burst=false; player.burstTime=0; player.fireRate = 14;
  updateHUD();
}

function startGame(){
  resetGame();
  GAME.running = true;
  lastSpawn = 0;
  lastPower = 0;
  requestAnimationFrame(loop);
}

function togglePause(){
  if(!GAME.running) return;
  GAME.paused = !GAME.paused;
  pauseBtn.innerText = GAME.paused ? 'Reanudar' : 'Pausar';
  if(!GAME.paused) requestAnimationFrame(loop);
}

startBtn.addEventListener('click', ()=> startGame());
pauseBtn.addEventListener('click', ()=> togglePause());
resetBtn.addEventListener('click', ()=> resetGame());

/* Shooting helper */
function shoot(x,y,angle=0, speed=6) {
  bullets.push({
    x, y, vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, r:4, color:'#ffd86b', life: 120
  });
}

/* Collision simple AABB and circle vs rect */
function rectColl(a,b){ return !(a.x + a.w < b.x || a.x > b.x + (b.w||0) || a.y + a.h < b.y || a.y > b.y + (b.h||0)); }
function circleRect(c, r){ // c: {x,y,r} r:{x,y,w,h}
  const cx = Math.max(r.x, Math.min(c.x, r.x + r.w));
  const cy = Math.max(r.y, Math.min(c.y, r.y + r.h));
  const dx = c.x - cx, dy = c.y - cy;
  return (dx*dx + dy*dy) < (c.r*c.r);
}

/* Game timers */
let frame = 0;
let lastSpawn = 0;
let lastPower = 0;

function updateHUD(){
  hud.innerHTML = `Score: ${GAME.score} &nbsp; Lives: ${GAME.lives} &nbsp; Wave: ${GAME.wave}`;
  highscoreEl.innerText = 'Mejor: ' + GAME.highscore;
}

/* Main loop */
function loop(){
  if(!GAME.running || GAME.paused) return;
  frame++;

  // Clear
  ctx.clearRect(0,0,W,H);
  // Fondo sutil
  const grd = ctx.createLinearGradient(0,0,0,H);
  grd.addColorStop(0,'rgba(255,255,255,0.02)');
  grd.addColorStop(1,'rgba(0,0,0,0.02)');
  ctx.fillStyle = grd;
  ctx.fillRect(0,0,W,H);

  // Player input
  let dy = 0, dx = 0;
  if(keys['arrowup'] || keys['w']) dy = -1;
  if(keys['arrowdown'] || keys['s']) dy = 1;
  if(keys['arrowleft'] || keys['a']) dx = -1;
  if(keys['arrowright'] || keys['d']) dx = 1;
  if(dx || dy){
    const len = Math.hypot(dx,dy) || 1;
    player.x += (dx/len) * player.speed;
    player.y += (dy/len) * player.speed;
    // clamp
    player.x = Math.max(12, Math.min(W - player.w - 12, player.x));
    player.y = Math.max(12, Math.min(H - player.h - 12, player.y));
  }

  // Shooting
  if((keys[' '] || keys['spacebar']) && player.cooldown <= 0){
    if(player.burst){
      // burst: 3-shot quick
      shoot(player.x + player.w, player.y + player.h/2 - 6, 0, 7);
      shoot(player.x + player.w, player.y + player.h/2 + 6, 0, 7);
      shoot(player.x + player.w, player.y + player.h/2, 0, 7);
      player.cooldown = player.fireRate - 6;
    } else {
      shoot(player.x + player.w, player.y + player.h/2, 0, 8);
      player.cooldown = player.fireRate;
    }
  }
  if(player.cooldown > 0) player.cooldown--;

  // Spawn enemies over time and by wave
  if(frame - lastSpawn > Math.max(40, 120 - GAME.wave*6)){
    spawnEnemy();
    lastSpawn = frame;
  }

  // Occasionally spawn powerups
  if(frame - lastPower > 900 + Math.random()*800){
    spawnPowerup();
    lastPower = frame;
  }

  // Increase difficulty slowly
  if(frame % 1800 === 0){ GAME.wave++; }

  // Update bullets
  for(let i = bullets.length-1; i >=0; i--){
    const b = bullets[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    // draw
    ctx.fillStyle = b.color;
    ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();

    // remove if offscreen or life
    if(b.x > W+20 || b.x < -20 || b.y < -20 || b.y > H+20 || b.life <= 0){
      bullets.splice(i,1);
    }
  }

  // Update enemies
  for(let i = enemies.length-1; i>=0; i--){
    const e = enemies[i];
    e.x -= e.speed;
    // draw enemy as triangle/ship
    ctx.save();
    ctx.translate(e.x, e.y);
    ctx.fillStyle = e.color;
    ctx.beginPath();
    ctx.moveTo(0, -e.h/2);
    ctx.lineTo(-e.w/2, e.h/2);
    ctx.lineTo(e.w/2, e.h/2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    // Collision with player
    if(rectColl({x:player.x,y:player.y,w:player.w,h:player.h}, {x:e.x-e.w/2,y:e.y-e.h/2,w:e.w,h:e.h})){
      // damage
      addParticles(player.x+player.w/2, player.y+player.h/2, '#ff6b6b', 12);
      enemies.splice(i,1);
      GAME.lives--;
      updateHUD();
      if(GAME.lives <= 0){ endGame(); return; }
      continue;
    }

    // Bullets vs enemies
    let hit = false;
    for(let j = bullets.length-1; j>=0; j--){
      const b = bullets[j];
      if(circleRect({x:b.x,y:b.y,r:b.r}, {x:e.x-e.w/2,y:e.y-e.h/2,w:e.w,h:e.h})){
        bullets.splice(j,1);
        e.hp--;
        addParticles(b.x,b.y,'#ffd86b',6);
        if(e.hp <= 0){
          // enemy destroyed
          GAME.score += 10;
          addParticles(e.x,e.y,'#ffb86b',18);
          enemies.splice(i,1);
          // small chance to drop extra powerup/points
          if(Math.random() < 0.12) {
            powerups.push({ x: e.x, y: e.y, r: 10, kind: 'life', speed: 1, color:'#8be0ff' });
          }
        }
        updateHUD();
        hit = true;
        break;
      }
    }
    if(hit) continue;

    // If enemy passes left edge, reduce lives
    if(e.x < -40){
      enemies.splice(i,1);
      GAME.lives--;
      updateHUD();
      if(GAME.lives <= 0){ endGame(); return; }
    }
  }

  // Update powerups
  for(let i = powerups.length-1; i>=0; i--){
    const p = powerups[i];
    p.x -= p.speed;
    // draw
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r-4, 0, Math.PI*2); ctx.fill();

    // pickup
    if(circleRect({x:player.x+player.w/2, y:player.y+player.h/2, r: player.w/2}, {x:p.x-p.r,y:p.y-p.r,w:p.r*2,h:p.r*2})){
      if(p.kind === 'burst'){
        player.burst = true;
        player.burstTime = frame + 1800; // long powerup
      } else if(p.kind === 'life'){
        GAME.lives = Math.min(9, GAME.lives + 1);
      }
      addParticles(p.x,p.y,'#7ee787',14);
      powerups.splice(i,1);
      updateHUD();
      continue;
    }
    if(p.x < -40) powerups.splice(i,1);
  }

  // powerup timeout
  if(player.burst && frame > player.burstTime){ player.burst = false; }

  // Update particles
  for(let i = particles.length-1; i>=0; i--){
    const pt = particles[i];
    pt.x += pt.vx; pt.y += pt.vy; pt.life--;
    ctx.globalAlpha = Math.max(0, pt.life/60);
    ctx.fillStyle = pt.color;
    ctx.beginPath(); ctx.arc(pt.x, pt.y, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    if(pt.life <= 0) particles.splice(i,1);
  }

  // Draw player (rounded rectangle + shield if burst)
  ctx.save();
  ctx.fillStyle = player.color;
  roundRect(ctx, player.x, player.y, player.w, player.h, 6, true, false);
  if(player.burst){
    ctx.strokeStyle = 'rgba(126,231,135,0.18)';
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(player.x+player.w/2, player.y+player.h/2, 40, 0, Math.PI*2); ctx.stroke();
  }
  ctx.restore();

  // Draw base on left
  ctx.fillStyle = 'rgba(255,255,255,0.04)';
  ctx.fillRect(8, H/2 - 60, 48, 120);
  ctx.fillStyle = '--';
  // score pop small
  ctx.fillStyle = '#ffffff22';

  // HUD small overlay icons
  // (extra flourishes)
  ctx.fillStyle = '#ffffff08';
  ctx.fillRect(0, H-28, W, 28);

  // Next frame
  // spawn small variation: when score high, spawn more
  if(Math.random() < 0.001 + GAME.wave*0.0006) {
    // tiny random enemy
    enemies.push({ x: W+40, y: 20 + Math.random()*(H-40), w: 12, h:12, hp:1, speed: 2 + Math.random()*1.6, color:'#ffd4d4' });
  }

  // request next
  if(GAME.running) requestAnimationFrame(loop);
}

/* Round rectangle helper */
function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof stroke === 'undefined') stroke = true;
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y,   x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x,   y + h, r);
  ctx.arcTo(x,   y + h, x,   y,   r);
  ctx.arcTo(x,   y,   x + w, y,   r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

/* End game */
function endGame(){
  GAME.running = false;
  // check highscore
  if(GAME.score > GAME.highscore){
    GAME.highscore = GAME.score;
    localStorage.setItem('guardianes_high', GAME.highscore);
    alert('¡Partida terminada! Nuevo récord: ' + GAME.highscore + '\nTu puntuación: ' + GAME.score);
  } else {
    alert('Partida terminada\nTu puntuación: ' + GAME.score + '\nMejor: ' + GAME.highscore);
  }
  updateHUD();
}

/* Simple auto-increment score over time (for gameplay feel) */
setInterval(()=> {
  if(GAME.running && !GAME.paused){
    GAME.score += 1;
    updateHUD();
  }
}, 1000);

/* Basic difficulty progression: more enemies each wave */
setInterval(()=> {
  if(GAME.running && !GAME.paused && Math.random() < 0.5){
    // occasional mini-wave
    const n = 1 + Math.floor(Math.random()* (1 + GAME.wave/3));
    for(let i=0;i<n;i++) spawnEnemy();
  }
}, 3000);

/* Start with a gentle intro screen */
(function intro(){
  ctx.fillStyle = '#000000aa';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = '#fff';
  ctx.font = '18px Inter, system-ui';
  ctx.textAlign = 'center';
  ctx.fillText('Pulsa "Comenzar Partida" para jugar', W/2, H/2);
})();

/* Update HUD initially */
updateHUD();

/* Expose simple keyboard shoot handler (space) */
window.addEventListener('keydown', (e) => {
  if(e.key === ' ' || e.key === 'Spacebar') {
    // prevent page scroll
    e.preventDefault();
  }
});

/* Reset highscore on double-click header (dev) - optional */
document.querySelector('header').addEventListener('dblclick', ()=>{
  if(confirm('¿Borrar mejor puntuación?')) {
    GAME.highscore = 0;
    localStorage.removeItem('guardianes_high');
    updateHUD();
  }
});

</script>
</body>
</html>

